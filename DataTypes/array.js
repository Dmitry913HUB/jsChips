/*          Объявление        */
{
    // Существует два варианта синтаксиса для создания пустого массива:

    let arr = new Array();
    arr = [];

    // Практически всегда используется второй вариант синтаксиса. 
    // В скобках мы можем указать начальные значения элементов:

    let fruits = ["Яблоко", "Апельсин", "Слива"];

    // Мы можем заменить элемент:
    fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]

    // Или добавить новый к существующему массиву:
    fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
    
    // Общее число элементов массива содержится в его свойстве length:
    fruits = ["Яблоко", "Апельсин", "Слива"];

    alert( fruits.length ); // 3

    // Вывести массив целиком можно при помощи alert.
    fruits = ["Яблоко", "Апельсин", "Слива"];

    alert( fruits ); // Яблоко, Апельсин, Слива

    // В массиве могут храниться элементы любого типа.
    // разные типы значений
    arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

    // получить элемент с индексом 1 (объект) и затем показать его свойство
    alert( arr[1].name ); // Джон

    // получить элемент с индексом 3 (функция) и выполнить её
    arr[3](); // привет
    
}
/*---------------------------------------*/
/*          Получение последних элементов при помощи «at»        */
{
    // синтаксис: fruits.at (-1):
    let fruits = ["Apple", "Orange", "Plum"];

    // то же самое, что и fruits[fruits.length-1]
    alert( fruits.at(-1) ); // Plum

    // Другими словами, arr.at(i):
    
    // это ровно то же самое, что и arr[i], если i >= 0.
    // для отрицательных значений i, он отступает от конца массива.    
}
/*---------------------------------------*/
/*          Методы pop/push, shift/unshift        */
{
    // Методы, работающие с концом массива:

    // pop
    // Удаляет последний элемент из массива и возвращает его:

    let fruits = ["Яблоко", "Апельсин", "Груша"];

    alert( fruits.pop() ); // удаляем "Груша" и выводим его

    alert( fruits ); // Яблоко, Апельсин

    // push
    // Добавляет элемент в конец массива:

    fruits = ["Яблоко", "Апельсин"];

    fruits.push("Груша");

    alert( fruits ); // Яблоко, Апельсин, Груша

    // Методы, работающие с началом массива:

    // shift
    // Удаляет из массива первый элемент и возвращает его:

    fruits = ["Яблоко", "Апельсин", "Груша"];

    alert( fruits.shift() ); // удаляем Яблоко и выводим его

    alert( fruits ); // Апельсин, Груша

    // unshift
    // Добавляет элемент в начало массива:

    fruits = ["Апельсин", "Груша"];

    fruits.unshift('Яблоко');

    alert( fruits ); // Яблоко, Апельсин, Груша

    // Методы push и unshift могут добавлять сразу несколько элементов:

    fruits = ["Яблоко"];

    fruits.push("Апельсин", "Груша");
    fruits.unshift("Ананас", "Лимон");

    // ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
    alert( fruits );
    
}
/*---------------------------------------*/
/*          Внутреннее устройство массива        */
{
    // Следует помнить, что в JavaScript существует 8 основных типов данных. 
    // Массив является объектом и, следовательно, ведёт себя как объект.

    // Например, копируется по ссылке:

    let fruits = ["Банан"]

    let arr = fruits; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

    alert( arr === fruits ); // true

    arr.push("Груша"); // массив меняется по ссылке

    alert( fruits ); // Банан, Груша - теперь два элемента

    // Варианты неправильного применения массива:

    // Добавление нечислового свойства, например: arr.test = 5.
    // Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).
    // Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.
    
}
/*---------------------------------------*/
/*          Эффективность        */
{
    // Методы push/pop выполняются быстро, а методы shift/unshift – медленно.

    // Чем больше элементов содержит массив, тем больше времени потребуется для того, 
    // чтобы их переместить, больше операций с памятью.

    // Метод pop не требует перемещения, потому что остальные элементы остаются 
    // с теми же индексами. Именно поэтому он выполняется очень быстро.

    // Аналогично работает метод push.
    
}
/*---------------------------------------*/
/*          Перебор элементов        */
{
    // Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:

    let arr = ["Яблоко", "Апельсин", "Груша"];

    for (let i = 0; i < arr.length; i++) {
        alert( arr[i] );
    }

    // Но для массивов возможен и другой вариант цикла, for..of:

    let fruits = ["Яблоко", "Апельсин", "Слива"];

    // проходит по значениям
    for (let fruit of fruits) {
        alert( fruit );
    }

    // Цикл for..of не предоставляет доступа к номеру текущего элемента, 
    // только к его значению, но в большинстве случаев этого достаточно. А также это короче.

    // Технически, так как массив является объектом, можно использовать и вариант for..in:

    arr = ["Яблоко", "Апельсин", "Груша"];

    for (let key in arr) {
        alert( arr[key] ); // Яблоко, Апельсин, Груша
    }

    // Но на самом деле это – плохая идея. Существуют скрытые недостатки этого способа:

    // Цикл for..in выполняет перебор всех свойств объекта, а не только цифровых.

    // В браузере и других программных средах также существуют так называемые «псевдомассивы» – 
    // объекты, которые выглядят, как массив. То есть, у них есть свойство length и индексы, 
    // но они также могут иметь дополнительные нечисловые свойства и методы, 
    // которые нам обычно не нужны. Тем не менее, цикл for..in выведет и их. Поэтому, 
    // если нам приходится иметь дело с объектами, похожими на массив, 
    // такие «лишние» свойства могут стать проблемой.

    // Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. 
    // Увеличение скорости выполнения может иметь значение только при возникновении узких мест. 
    // Но мы всё же должны представлять разницу.

    // В общем, не следует использовать цикл for..in для массивов.
    
}
/*---------------------------------------*/
/*          Немного о «length»        */
{

    // Свойство length автоматически обновляется при изменении массива. Если быть точными, 
    // это не количество элементов массива, а наибольший цифровой индекс плюс один.

    // Например, единственный элемент, имеющий большой индекс, даёт большую длину:

    let fruits = [];
    fruits[123] = "Яблоко";

    alert( fruits.length ); // 124

    // Обратите внимание, что обычно мы не используем массивы таким образом.

    // Ещё один интересный факт о свойстве length – его можно перезаписать.

    // Если мы вручную увеличим его, ничего интересного не произойдёт. 
    // Зато, если мы уменьшим его, массив станет короче. Этот процесс необратим, 
    // как мы можем понять из примера:

    let arr = [1, 2, 3, 4, 5];

    arr.length = 2; // укорачиваем до двух элементов
    alert( arr ); // [1, 2]

    arr.length = 5; // возвращаем length как было
    alert( arr[3] ); // undefined: значения не восстановились

    // Таким образом, самый простой способ очистить массив – это arr.length = 0;.
    
}
/*---------------------------------------*/
/*          new Array()        */
{
    // Существует ещё один вариант синтаксиса для создания массива:

    let arr = new Array("Яблоко", "Груша", "и тд");
    // Он редко применяется, так как квадратные скобки [] короче. Кроме того, у него есть хитрая особенность.

    // Если new Array вызывается с одним аргументом, который представляет собой число, 
    // он создаёт массив без элементов, но с заданной длиной.

    // Давайте посмотрим, как можно оказать себе медвежью услугу:

    arr = new Array(2); // создастся ли массив [2]?

    alert( arr[0] ); // undefined! нет элементов.

    alert( arr.length ); // length 2
    // Как мы видим, в коде, представленном выше, в new Array(number) все элементы равны undefined.

    // Чтобы избежать появления таких неожиданных ситуаций, мы обычно используем квадратные скобки, 
    // если, конечно, не знаем точно, что по какой-то причине нужен именно Array.
    
}
/*---------------------------------------*/
/*          Многомерные массивы        */
{
    // Массивы могут содержать элементы, которые тоже являются массивами. 
    // Это можно использовать для создания многомерных массивов, например, для хранения матриц:

    let matrix = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];

    alert( matrix[1][1] ); // 5, центральный элемент
    
}
/*---------------------------------------*/
/*          toString        */
{
    // Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.

    let arr = [1, 2, 3];

    alert( arr ); // 1,2,3
    alert( String(arr) === '1,2,3' ); // true

    //Давайте теперь попробуем следующее:

    alert( [] + 1 ); // "1"
    alert( [1] + 1 ); // "11"
    alert( [1,2] + 1 ); // "1,21"

    // Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, 
    // они реализуют только преобразование toString, таким образом, здесь []
    // становится пустой строкой, [1] становится "1", а [1,2] становится "1,2".

    // Когда бинарный оператор плюс "+" добавляет что-либо к строке, 
    // он тоже преобразует это в строку, таким образом:

    alert( "" + 1 ); // "1"
    alert( "1" + 1 ); // "11"
    alert( "1,2" + 1 ); // "1,21"
    
}
/*---------------------------------------*/
/*          Не сравнивайте массивы при помощи ==        */
{
    // У этого оператора нет специального подхода к массивам, 
    // он работает с ними, как и с любыми другими объектами.

    alert( [] == [] ); // false
    alert( [0] == [0] ); // false

    // Технически эти массивы являются разными объектами. Так что они не равны. 
    // Оператор == не выполняет поэлементное сравнение.

    // Сравнение с примитивами также может дать, казалось бы, странные результаты:

    alert( 0 == [] ); // true

    alert('0' == [] ); // false

    // Здесь, в обоих случаях, мы сравниваем примитив с объектом массива. 
    // Таким образом, массив [] преобразуется в примитив с целью сравнения и становится пустой строкой ''.

    // Затем продолжается процесс сравнения с примитивами, как описано в главе Преобразование типов:

    // после того, как [] был преобразован в ''
    alert( 0 == '' ); // true, так как '' преобразуется в число 0

    alert('0' == '' ); // false, нет преобразования типов, разные стро
    
}
/*---------------------------------------*/
/*          Итого        */
{

    // Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.

    // Объявление:

    // // квадратные скобки (обычно)
    // let arr = [item1, item2...];

    // // new Array (очень редко)
    // let arr = new Array(item1, item2...);
    // Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.

    // Свойство length отражает длину массива или, если точнее, 
    // его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.
    // Если мы уменьшаем length вручную, массив укорачивается.
    // Получение элементов:

    // Мы можем получить элемент по его индексу, например arr[0].
    // Также мы можем использовать метод at(i) для получения элементов с отрицательным индексом, 
    // для отрицательных значений i, он отступает от конца массива. 
    // В остальном он работает так же, как arr[i], если i >= 0.
    // Мы можем использовать массив как двустороннюю очередь, используя следующие операции:

    // push(...items)добавляет items в конец массива.
    // pop() удаляет элемент в конце массива и возвращает его.
    // shift() удаляет элемент в начале массива и возвращает его.
    // unshift(...items) добавляет items в начало массива.
    // Чтобы пройтись по элементам массива:

    // for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
    // for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
    // for (let i in arr) – никогда не используйте для массивов!
    
}
/*---------------------------------------*/
/*          задачи        */
{
    // zadacha 2
    let styles = ['djaz', 'blyz'];
    styles.push('rock');
    styles[Math.floor((styles.length - 1) / 2)] = 'klasika';
    alert(styles.shift());
    styles.unshift('rep', 'reggi');
    
    // zadacha 3

    let arr = ["a", "b"];

    arr.push(function() {
        alert( this );
    })

    arr[2](); // a,b,function(){...}

    // zadacha 4

    function sumInput() {

        let numbers = [];
      
        while (true) {
      
          let value = prompt("Введите число", 0);
      
          // Прекращаем ввод?
          if (value === "" || value === null || !isFinite(value)) break;
      
          numbers.push(+value);
        }
      
        let sum = 0;
        for (let number of numbers) {
          sum += number;
        }
        return sum;
    }
      
    alert( sumInput() );

    // zadacha 5

    function getMaxSubSum(arr) {
        let maxSum = 0;
        let partialSum = 0;
      
        for (let item of arr) { // для каждого элемента массива
          partialSum += item; // добавляем значение элемента к partialSum
          maxSum = Math.max(maxSum, partialSum); // запоминаем максимум на данный момент
          if (partialSum < 0) partialSum = 0; // ноль если отрицательное
        }
      
        return maxSum;
      }
      
      alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
      alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
      alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
      alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
      alert( getMaxSubSum([1, 2, 3]) ); // 6
      alert( getMaxSubSum([-1, -2, -3]) ); // 0
}
/*---------------------------------------*/