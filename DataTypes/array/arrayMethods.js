/*          Добавление/удаление элементов        */
{
    // arr.push(...items) – добавляет элементы в конец,
    // arr.pop() – извлекает элемент из конца,
    // arr.shift() – извлекает элемент из начала,
    // arr.unshift(...items) – добавляет элементы в начало.

    // splice

    // Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами. 
    // Умеет всё: добавлять, удалять и заменять элементы.

    // arr.splice(start[, deleteCount, elem1, ..., elemN])

    let arr = ["Я", "изучаю", "JavaScript"];

    arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент

    alert( arr ); // осталось ["Я", "JavaScript"]

    // В следующем примере мы удалим 3 элемента и заменим их двумя другими.

    arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

    // удалить 3 первых элемента и заменить их другими
    arr.splice(0, 3, "Давай", "танцевать");

    alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

    // Здесь видно, что splice возвращает массив из удалённых элементов:

    arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

    // удалить 2 первых элемента
    let removed = arr.splice(0, 2);

    alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов

    // Метод splice также может вставлять элементы без удаления, 
    // для этого достаточно установить deleteCount в 0:

    arr = ["Я", "изучаю", "JavaScript"];

    // с индекса 2
    // удалить 0 элементов
    // вставить "сложный", "язык"
    arr.splice(2, 0, "сложный", "язык");

    alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

    // Отрицательные индексы разрешены
    // В этом и в других методах массива допускается использование отрицательных индексов.
    // Они определяют позицию с конца массива, как тут:

    arr = [1, 2, 5];

    // начиная с индекса -1 (перед последним элементом)
    // удалить 0 элементов,
    // затем вставить числа 3 и 4
    arr.splice(-1, 0, 3, 4);

    alert( arr ); // 1,2,3,4,5

    // slice

    arr.slice([start], [end])

    // Это похоже на строковый метод str.slice, но вместо подстрок возвращает подмассивы.

    arr = ["t", "e", "s", "t"];

    alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

    alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)

    // concat

    // Метод arr.concat создаёт новый массив, в который копирует данные 
    // из других массивов и дополнительные значения.

    // Синтаксис:

    arr.concat(arg1, arg2)

    arr = [1, 2];

    // создать массив из: arr и [3,4]
    alert( arr.concat([3, 4]) ); // 1,2,3,4

    // создать массив из: arr и [3,4] и [5,6]
    alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

    // создать массив из: arr и [3,4], потом добавить значения 5 и 6
    alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6

    // Обычно он копирует только элементы из массивов. Другие объекты, 
    // даже если они выглядят как массивы, добавляются как есть:

    arr = [1, 2];

    let arrayLike = {
        0: "что-то",
        length: 1
    };

    alert( arr.concat(arrayLike) ); // 1,2,[object Object]

    // …Но если массивоподобный объект имеет специальное свойство Symbol.isConcatSpreadable, 
    // то он обрабатывается как массив, с помощью concat: вместо него добавляются его элементы:

    arr = [1, 2];

    arrayLike = {
        0: "что-то",
        1: "ещё",
        [Symbol.isConcatSpreadable]: true,
        length: 2
    };

    alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
    
}
/*---------------------------------------*/
/*          Перебор: forEach        */
{

    // Метод arr.forEach позволяет запускать функцию для каждого элемента массива.

    // Синтаксис:

    arr.forEach(function(item, index, array) {
    // ... делать что-то с item
    });

    // Например, этот код выведет на экран каждый элемент массива:

    // Вызов alert для каждого элемента
    ["Бильбо", "Гэндальф", "Назгул"].forEach(alert);

    // А этот вдобавок расскажет и о позиции элемента в целевом массиве:

    ["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
        alert(`У ${item} индекс ${index} в ${array}`);
    });
        
}
/*---------------------------------------*/
/*          Поиск в массиве        */
{

    // indexOf/lastIndexOf и includes

    // У методов arr.indexOf и arr.includes одинаковый синтаксис и они делают по сути то же самое, 
    // что и их строковые аналоги, но работают с элементами вместо символов:

    // arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, 
    // на котором был найден искомый элемент, в противном случае -1.
    // arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.

    let arr = [1, 0, false];

    alert( arr.indexOf(0) ); // 1
    alert( arr.indexOf(false) ); // 2
    alert( arr.indexOf(null) ); // -1

    alert( arr.includes(1) ); // true

    // Пожалуйста, обратите внимание, что методы используют строгое сравнение ===. 
    // Таким образом, если мы ищем false, он находит именно false, а не ноль.

    // Метод arr.lastIndexOf похож на indexOf, но ищет справа налево.

    let fruits = ['Яблоко', 'Апельсин', 'Яблоко']

    alert( fruits.indexOf('Яблоко') ); // 0 (первый 'Яблоко')
    alert( fruits.lastIndexOf('Яблоко') ); // 2 (последний 'Яблоко')

    // Незначительная, но заслуживающая внимания особенность includes – 
    // он правильно обрабатывает NaN, в отличие от indexOf:

    arr = [NaN];
    alert( arr.indexOf(NaN) ); // -1 (неверно, должен быть 0)
    alert( arr.includes(NaN) );// true (верно)

    // find и findIndex/findLastIndex

    let result = arr.find(function(item, index, array) {
        // если true - возвращается текущий элемент и перебор прерывается
        // если все итерации оказались ложными, возвращается undefined
    });

    // Функция вызывается по очереди для каждого элемента массива:

    // item – очередной элемент.
    // index – его индекс.
    // array – сам массив.

    let users = [
        {id: 1, name: "Вася"},
        {id: 2, name: "Петя"},
        {id: 3, name: "Маша"}
      ];
      
    let user = users.find(item => item.id == 1);
    
    alert(user.name); // Вася

    // Метод arr.findLastIndex похож на findIndex, но ищет справа налево, наподобие lastIndexOf.
    
    users = [
        {id: 1, name: "Вася"},
        {id: 2, name: "Петя"},
        {id: 3, name: "Маша"},
        {id: 4, name: "Вася"}
      ];
      
    // Найти индекс первого Васи
    alert(users.findIndex(user => user.name == 'Вася')); // 0
    
    // Найти индекс последнего Васи
    alert(users.findLastIndex(user => user.name == 'Вася')); // 3

    // filter

    // Метод find ищет один (первый) элемент, который заставит функцию вернуть true
    // Если найденных элементов может быть много, можно использовать arr.filter(fn).

    let results = arr.filter(function(item, index, array) {
        // если `true` -- элемент добавляется к results и перебор продолжается
        // возвращается пустой массив в случае, если ничего не найдено
    });

    users = [
        {id: 1, name: "Вася"},
        {id: 2, name: "Петя"},
        {id: 3, name: "Маша"}
      ];
      
    // возвращает массив, состоящий из двух первых пользователей
    let someUsers = users.filter(item => item.id < 3);
    
    alert(someUsers.length); // 2
    
}
/*---------------------------------------*/
/*          Преобразование массива        */
{

    // map

    // Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

    // Синтаксис:

    let result = arr.map(function(item, index, array) {
    // возвращается новое значение вместо элемента
    });

    // Например, здесь мы преобразуем каждый элемент в его длину:

    let lengths = ["Бильбо", "Гэндальф", "Назгул"].map(item => item.length);
    alert(lengths); // 6,8,6

    // sort(fn)
    // Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.

    let arr = [ 1, 2, 15 ];

    // метод сортирует содержимое arr
    arr.sort();

    alert( arr );  // 1, 15, 2

    // Буквально, элементы преобразуются в строки при сравнении. 
    // Для строк применяется лексикографический порядок, и действительно выходит, что "2" > "15".

    function compare(a, b) {
        if (a > b) return 1; // если первое значение больше второго
        if (a == b) return 0; // если равны
        if (a < b) return -1; // если первое значение меньше второго
    }

    // Например, для сортировки чисел:

    function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
    }

    arr = [ 1, 2, 15 ];

    arr.sort(compareNumeric);

    alert(arr);  // 1, 2, 15

    // Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются – 
    // ничто не мешает нам вывести их на экран:

    [1, -2, 15, 2, 0, 8].sort(function(a, b) {
        alert( a + " <> " + b );
        return a - b;
    });

    // Функция сравнения может вернуть любое число
    // На самом деле от функции сравнения требуется любое положительное число, 
    // чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше».

    // Это позволяет писать более короткие функции:

    arr = [ 1, 2, 15 ];

    arr.sort(function(a, b) { return b - a; });

    alert(arr);  // 15, 2, 1

    // Лучше использовать стрелочные функции

    arr.sort( (a, b) => a - b );

    // Используйте localeCompare для строк
    // Помните алгоритм сравнения строк? По умолчанию, он сравнивает буквы по их кодам.

    // Для многих алфавитов лучше использовать метод str.localeCompare, 
    // для правильной сортировки букв, таких как Ö.

    // Например, отсортируем несколько стран на немецком языке:

    let countries = ['Österreich', 'Andorra', 'Vietnam'];

    alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (неправильно)

    alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (правильно!)

    // Метод arr.reverse меняет порядок элементов в arr на обратный.
    
    arr = [1, 2, 3, 4, 5];
    arr.reverse();

    alert( arr ); // 5,4,3,2,1

    // split и join

    // Ситуация из реальной жизни. Мы пишем приложение для обмена сообщениями, 
    // и посетитель вводит имена тех, кому его отправить, через запятую: Вася, Петя, Маша. 
    // Но нам-то гораздо удобнее работать с массивом имён, чем с одной строкой. Как его получить?

    // Метод str.split(delim) именно это и делает. Он разбивает строку на массив по заданному разделителю delim.

    // В примере ниже таким разделителем является строка из запятой и пробела.

    let names = 'Вася, Петя, Маша';

    arr = names.split(', ');

    for (let name of arr) {
        alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
    }

    arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

    alert(arr); // Вася, Петя

    // Разбивка по буквам
    // Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:

    let str = "тест";

    alert( str.split('') ); // т,е,с,т

    // Вызов arr.join(glue) делает в точности противоположное split. 
    // Он создаёт строку из элементов arr, вставляя glue между ними.

    arr = ['Вася', 'Петя', 'Маша'];

    str = arr.join(';'); // объединить массив в строку через ;

    alert( str ); // Вася;Петя;Маша
    
}
/*---------------------------------------*/
/*          Итого        */
{
    
}
/*---------------------------------------*/
/*          Итого        */
{
    
}
/*---------------------------------------*/
/*          Итого        */
{
    
}
/*---------------------------------------*/

