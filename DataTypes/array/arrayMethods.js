/*          Добавление/удаление элементов        */
{
    // arr.push(...items) – добавляет элементы в конец,
    // arr.pop() – извлекает элемент из конца,
    // arr.shift() – извлекает элемент из начала,
    // arr.unshift(...items) – добавляет элементы в начало.

    // splice

    // Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами. 
    // Умеет всё: добавлять, удалять и заменять элементы.

    // arr.splice(start[, deleteCount, elem1, ..., elemN])

    let arr = ["Я", "изучаю", "JavaScript"];

    arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент

    alert( arr ); // осталось ["Я", "JavaScript"]

    // В следующем примере мы удалим 3 элемента и заменим их двумя другими.

    arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

    // удалить 3 первых элемента и заменить их другими
    arr.splice(0, 3, "Давай", "танцевать");

    alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

    // Здесь видно, что splice возвращает массив из удалённых элементов:

    arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

    // удалить 2 первых элемента
    let removed = arr.splice(0, 2);

    alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов

    // Метод splice также может вставлять элементы без удаления, 
    // для этого достаточно установить deleteCount в 0:

    arr = ["Я", "изучаю", "JavaScript"];

    // с индекса 2
    // удалить 0 элементов
    // вставить "сложный", "язык"
    arr.splice(2, 0, "сложный", "язык");

    alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

    // Отрицательные индексы разрешены
    // В этом и в других методах массива допускается использование отрицательных индексов.
    // Они определяют позицию с конца массива, как тут:

    arr = [1, 2, 5];

    // начиная с индекса -1 (перед последним элементом)
    // удалить 0 элементов,
    // затем вставить числа 3 и 4
    arr.splice(-1, 0, 3, 4);

    alert( arr ); // 1,2,3,4,5

    // slice

    arr.slice([start], [end])

    // Это похоже на строковый метод str.slice, но вместо подстрок возвращает подмассивы.

    arr = ["t", "e", "s", "t"];

    alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

    alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)

    // concat

    // Метод arr.concat создаёт новый массив, в который копирует данные 
    // из других массивов и дополнительные значения.

    // Синтаксис:

    arr.concat(arg1, arg2)

    arr = [1, 2];

    // создать массив из: arr и [3,4]
    alert( arr.concat([3, 4]) ); // 1,2,3,4

    // создать массив из: arr и [3,4] и [5,6]
    alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

    // создать массив из: arr и [3,4], потом добавить значения 5 и 6
    alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6

    // Обычно он копирует только элементы из массивов. Другие объекты, 
    // даже если они выглядят как массивы, добавляются как есть:

    arr = [1, 2];

    let arrayLike = {
        0: "что-то",
        length: 1
    };

    alert( arr.concat(arrayLike) ); // 1,2,[object Object]

    // …Но если массивоподобный объект имеет специальное свойство Symbol.isConcatSpreadable, 
    // то он обрабатывается как массив, с помощью concat: вместо него добавляются его элементы:

    arr = [1, 2];

    arrayLike = {
        0: "что-то",
        1: "ещё",
        [Symbol.isConcatSpreadable]: true,
        length: 2
    };

    alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
    
}
/*---------------------------------------*/
/*          Перебор: forEach        */
{

    // Метод arr.forEach позволяет запускать функцию для каждого элемента массива.

    // Синтаксис:

    arr.forEach(function(item, index, array) {
    // ... делать что-то с item
    });

    // Например, этот код выведет на экран каждый элемент массива:

    // Вызов alert для каждого элемента
    ["Бильбо", "Гэндальф", "Назгул"].forEach(alert);

    // А этот вдобавок расскажет и о позиции элемента в целевом массиве:

    ["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
        alert(`У ${item} индекс ${index} в ${array}`);
    });
        
}
/*---------------------------------------*/
/*          Поиск в массиве        */
{

    // indexOf/lastIndexOf и includes

    // У методов arr.indexOf и arr.includes одинаковый синтаксис и они делают по сути то же самое, 
    // что и их строковые аналоги, но работают с элементами вместо символов:

    // arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, 
    // на котором был найден искомый элемент, в противном случае -1.
    // arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.

    let arr = [1, 0, false];

    alert( arr.indexOf(0) ); // 1
    alert( arr.indexOf(false) ); // 2
    alert( arr.indexOf(null) ); // -1

    alert( arr.includes(1) ); // true

    // Пожалуйста, обратите внимание, что методы используют строгое сравнение ===. 
    // Таким образом, если мы ищем false, он находит именно false, а не ноль.

    // Метод arr.lastIndexOf похож на indexOf, но ищет справа налево.

    let fruits = ['Яблоко', 'Апельсин', 'Яблоко']

    alert( fruits.indexOf('Яблоко') ); // 0 (первый 'Яблоко')
    alert( fruits.lastIndexOf('Яблоко') ); // 2 (последний 'Яблоко')

    // Незначительная, но заслуживающая внимания особенность includes – 
    // он правильно обрабатывает NaN, в отличие от indexOf:

    arr = [NaN];
    alert( arr.indexOf(NaN) ); // -1 (неверно, должен быть 0)
    alert( arr.includes(NaN) );// true (верно)

    // find и findIndex/findLastIndex

    let result = arr.find(function(item, index, array) {
        // если true - возвращается текущий элемент и перебор прерывается
        // если все итерации оказались ложными, возвращается undefined
    });

    // Функция вызывается по очереди для каждого элемента массива:

    // item – очередной элемент.
    // index – его индекс.
    // array – сам массив.

    let users = [
        {id: 1, name: "Вася"},
        {id: 2, name: "Петя"},
        {id: 3, name: "Маша"}
      ];
      
    let user = users.find(item => item.id == 1);
    
    alert(user.name); // Вася

    // Метод arr.findLastIndex похож на findIndex, но ищет справа налево, наподобие lastIndexOf.
    
    users = [
        {id: 1, name: "Вася"},
        {id: 2, name: "Петя"},
        {id: 3, name: "Маша"},
        {id: 4, name: "Вася"}
      ];
      
    // Найти индекс первого Васи
    alert(users.findIndex(user => user.name == 'Вася')); // 0
    
    // Найти индекс последнего Васи
    alert(users.findLastIndex(user => user.name == 'Вася')); // 3

    // filter

    // Метод find ищет один (первый) элемент, который заставит функцию вернуть true
    // Если найденных элементов может быть много, можно использовать arr.filter(fn).

    let results = arr.filter(function(item, index, array) {
        // если `true` -- элемент добавляется к results и перебор продолжается
        // возвращается пустой массив в случае, если ничего не найдено
    });

    users = [
        {id: 1, name: "Вася"},
        {id: 2, name: "Петя"},
        {id: 3, name: "Маша"}
      ];
      
    // возвращает массив, состоящий из двух первых пользователей
    let someUsers = users.filter(item => item.id < 3);
    
    alert(someUsers.length); // 2
    
}
/*---------------------------------------*/
/*          Преобразование массива        */
{
    
}
/*---------------------------------------*/
/*          Итого        */
{
    
}
/*---------------------------------------*/
/*          Итого        */
{
    
}
/*---------------------------------------*/
/*          Итого        */
{
    
}
/*---------------------------------------*/

