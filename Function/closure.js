"use strict"
/*          Пара вопросов          */
{

    // Функция sayHi использует внешнюю переменную name. Какое значение будет использовать функция при выполнении?

    let name = "John";

    function sayHi() {
    alert("Hi, " + name);
    }

    name = "Pete";

    sayHi(); // что будет показано: "John" или "Pete"?
    // Такие ситуации распространены и в браузерной и в серверной разработке. 
    // Выполнение функции может быть запланировано позже, чем она была создана, например, 
    // после какого-нибудь пользовательского действия или сетевого запроса.

    // Итак, вопрос в том, получит ли она доступ к последним изменениям?

    // Функция makeWorker создаёт другую функцию и возвращает её. 
    // Новая функция может быть вызвана откуда-то ещё. 
    // Получит ли она доступ к внешним переменным из места своего создания или места выполнения или из обоих?

    function makeWorker() {
    let name = "Pete";

    return function() {
        alert(name);
    };
    }

    name = "John";

    // create a function
    let work = makeWorker();

    // call it
    work(); // что будет показано? "Pete" (из места создания) или "John" (из места выполнения)

    // в обоих случаях Pete

}
/*---------------------------------------*/
/*          Лексическое Окружение          */
{

    // Функция получает текущее значение внешних переменных, то есть их последнее значение

    // Старые значения переменных нигде не сохраняются. Когда функция хочет получить доступ к переменной, 
    // она берёт её текущее значение из своего или внешнего лексического окружения.

    // Так что ответ на первый вопрос: Pete:

    let name = "John";

    function sayHi() {
    alert("Hi, " + name);
    }

    name = "Pete"; // (*)

    sayHi(); // Pete
    // Порядок выполнения кода, приведённого выше:

    // В глобальном лексическом окружении есть name: "John".
    // На строке (*) глобальная переменная изменяется, теперь name: "Pete".
    // Момент, когда выполняется функция sayHi() и берёт переменную name извне. 
    // Теперь из глобального лексического окружения, где переменная уже равна "Pete".
    // Один вызов – одно лексическое окружение
    // Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, 
    // когда функция выполняется.

    // И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, 
    // со своими, специфичными для этого вызова, локальными переменными и параметрами.

    // Лексическое окружение – это специальный внутренний объект
    // «Лексическое окружение» – это специальный внутренний объект. 
    // Мы не можем получить его в нашем коде и изменять напрямую. 
    // Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые переменные для освобождения 
    // памяти и выполнять другие внутренние уловки, 
    // но видимое поведение объекта должно оставаться таким, как было описано.

}
/*---------------------------------------*/
/*          Вложенные функции          */
{

    // Мы можем использовать это для упорядочивания нашего кода, например, как здесь:

    function sayHiBye(firstName, lastName) {

    // функция-помощник, которую мы используем ниже
    function getFullName() {
        return firstName + " " + lastName;
    }

    alert( "Hello, " + getFullName() );
    alert( "Bye, " + getFullName() );

    }
    // Такой возможности нет: count – локальная переменная функции, мы не можем получить к ней доступ извне.
    // Для каждого вызова makeCounter() создаётся новое лексическое окружение функции, 
    // со своим собственным count. Так что получившиеся функции counter – независимы.
    // Вот демо:

    function makeCounter() {
    let count = 0;
    return function() {
        return count++;
    };
    }

    let counter1 = makeCounter();
    let counter2 = makeCounter();

    alert( counter1() ); // 0
    alert( counter1() ); // 1

    alert( counter2() ); // 0 (независимо)

}
/*---------------------------------------*/
/*          Окружение в деталях          */
{

    // Теперь ответ на второй вопрос из начала главы должен быть очевиден.

    // Функция work() в коде ниже получает name из того места, 
    // где была создана, через ссылку на внешнее лексическое окружение:


    // Так что результатом будет "Pete".

    // Но, если бы в makeWorker() не было let name, 
    // тогда бы поиск продолжился дальше и была бы взята глобальная переменная, 
    // как мы видим из приведённой выше цепочки. В таком случае, 
    // результатом было бы "John".

    // Замыкания
    // В программировании есть общий термин: «замыкание», – 
    // которое должен знать каждый разработчик.

    // Замыкание – это функция, которая запоминает свои внешние переменные и 
    // может получить к ним доступ. В некоторых языках это невозможно, 
    // или функция должна быть написана специальным образом, чтобы получилось 
    // замыкание. Но, как было описано выше, в JavaScript, 
    // все функции изначально являются замыканиями 
    // (есть только одно исключение, про которое будет рассказано 
    // в Синтаксис "new Function").

    // То есть они автоматически запоминают, где были созданы, 
    // с помощью скрытого свойства [[Environment]], и все они могут получить 
    // доступ к внешним переменным.

    // Когда на собеседовании фронтенд-разработчик получает вопрос: 
    // «что такое замыкание?», – правильным ответом будет определение 
    // замыкания и объяснения того факта, что все функции в JavaScript 
    // являются замыканиями, и, может быть, несколько слов о технических деталях: 
    // свойстве [[Environment]] и о том, как работает лексическое окружение.

}
/*---------------------------------------*/
/*          Блоки кода и циклы, IIFE          */
{

    // Когда выполнение попадает в блок if, 
    // для этого блока создаётся новое лексическое окружение.

    // У него есть ссылка на внешнее окружение, 
    // так что phrase может быть найдена. 
    // Но все переменные, Function Expression, 
    // а так же Function Declaration в строгом режиме, 
    // объявленные внутри if, остаются в его лексическом окружении и 
    // не видны снаружи.

    // Например, после завершения if следующий alert не увидит user, 
    // что вызовет ошибку

    // Для цикла у каждой итерации своё отдельное лексическое окружение. 
    // Если переменная объявлена в for(let ...), то она также в нём:

    for (let i = 0; i < 10; i++) {
    // У каждой итерации цикла своё собственное лексическое окружение
    // {i: value}
    }

    alert(i); // Ошибка, нет такой переменной

    // Кроме скобок, существуют и другие пути показать JavaScript, 
    // что мы имеем в виду Function Expression:

    // Пути создания IIFE

    (function() {
    alert("Скобки вокруг функции");
    })();

    (function() {
    alert("Скобки вокруг всего");
    }());

    !function() {
    alert("Выражение начинается с логического оператора NOT");
    }();

    +function() {
    alert("Выражение начинается с унарного плюса");
    }();
    // Во всех перечисленных случаях мы объявляем Function Expression и 
    // немедленно выполняем его. Ещё раз заметим, что в настоящий момент нет 
    // необходимости писать подобный код.

}
/*---------------------------------------*/
/*          Сборка мусора          */
{

    // …Но, если есть вложенная функция, 
    // которая всё ещё доступна после выполнения f, 
    // то у неё есть свойство [[Environment]], 
    // которое ссылается на внешнее лексическое окружение, 
    // тем самым оставляя его достижимым, «живым»:

    function f() {
    let value = 123;

    function g() { alert(value); }

    return g;
    }

    let g = f(); // g доступно и продолжает держать внешнее лексическое окружение в памяти
    // Обратите внимание, если f() вызывается несколько раз и возвращаемые 
    // функции сохраняются, тогда все соответствующие объекты лексического 
    // окружения продолжат держаться в памяти. Вот три такие функции в коде ниже:

    function f() {
    let value = Math.random();

    return function() { alert(value); };
    }

    // три функции в массиве, каждая из них ссылается на лексическое окружение
    // из соответствующего вызова f()
    let arr = [f(), f(), f()];
    // Объект лексического окружения умирает, когда становится н
    // едоступным (как и любой другой объект). Другими словами, 
    // он существует только до того момента, пока есть хотя бы одна 
    // вложенная функция, которая ссылается на него.

    // В следующем коде, после того как g станет недоступным, 
    // лексическое окружение функции (и, соответственно, value) 
    // будет удалено из памяти:

    function f() {
    let value = 123;

    function g() { alert(value); }

    return g;
    }

    g = f(); // пока g существует,
    // соответствующее лексическое окружение существует

    g = null; // ...а теперь память очищается

}
/*---------------------------------------*/
/*          Задачи          */
{

    // zadacha 2 Объект счётчика

    function Counter() {
        let count = 0;
      
        this.up = function() {
          return ++count;
        };
      
        this.down = function() {
          return --count;
        };
      }
      
      let counter = new Counter();
      
      alert( counter.up() ); // 1
      alert( counter.up() ); // 2
      alert( counter.down() ); // 1

    // zadacha 3

    let phrase = "Hello";

    if (true) {
    let user = "John";

    function sayHi() {
        alert(`${phrase}, ${user}`);
    }
    }

    sayHi();
    // решение
    // Результатом будет ошибка.

    // Функция sayHi объявлена внутри if, 
    // так что она живёт только внутри этого блока. Снаружи нет sayHi.

    // zadacha 4 Сумма с помощью замыканий

    function sum(a){
        return function(b) {
            return a + b;
          }
    }

    alert( sum(1)(2) ); // 3
    alert( sum(5)(-1) ); // 4

    // zadacha 5 Фильтрация с помощью функции

    function inBetween(a, b) {
        return function(x){
            return x >= a && x <= b;
        }
      }
      
      function inArray(arr) {
        return function(x){
            return arr.includes(x);
        }
      }
    
    let arr = [1, 2, 3, 4, 5, 6, 7];

    alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6

    alert( arr.filter(inArray([1, 2, 10])) ); // 1,2

    // zadacha 6 Сортировать по полю

    function byField(key){
        return (a, b) => a[key] > b[key] ? 1 : -1
    }
    
    let users = [
        { name: "John", age: 20, surname: "Johnson" },
        { name: "Pete", age: 18, surname: "Peterson" },
        { name: "Ann", age: 19, surname: "Hathaway" }
      ];

    users.sort(byField('name'));
    users.sort(byField('age'));

    // zadacha 7 Армия функций

    function makeArmy() {

        let shooters = [];
      
        for(let i = 0; i < 10; i++) {
          let shooter = function() { // функция shooter
            alert( i ); // должна выводить порядковый номер
          };
          shooters.push(shooter);
      
      
        }
      
        return shooters;
      }
      
      let army = makeArmy();
      
      army[0](); // 0
      army[5](); // 5

    //   Можно использовать другой трюк, давайте 
    //   рассмотрим его для лучшего понимания предмета:

    function makeArmy() {
    let shooters = [];

    let i = 0;
    while (i < 10) {
        let j = i;
        let shooter = function() { // функция shooter
        alert( j ); // должна выводить порядковый номер
        };
        shooters.push(shooter);
        i++;
    }

    return shooters;
    }

    army = makeArmy();

    army[0](); // 0
    army[5](); // 5

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/