"use strict"
/*          Прозрачное кеширование          */
{

    // Вот код с объяснениями:

    function slow(x) {
    // здесь могут быть ресурсоёмкие вычисления
    alert(`Called with ${x}`);
    return x;
    }

    function cachingDecorator(func) {
    let cache = new Map();

    return function(x) {
        if (cache.has(x)) {    // если кеш содержит такой x,
        return cache.get(x); // читаем из него результат
        }

        let result = func(x); // иначе, вызываем функцию

        cache.set(x, result); // и кешируем (запоминаем) результат
        return result;
    };
    }

    slow = cachingDecorator(slow);

    alert( slow(1) ); // slow(1) кешируем
    alert( "Again: " + slow(1) ); // возвращаем из кеша

    alert( slow(2) ); // slow(2) кешируем
    alert( "Again: " + slow(2) ); // возвращаем из кеша

    // В коде выше cachingDecorator – это декоратор, специальная функция, 
    // которая принимает другую функцию и изменяет её поведение.

    // Идея состоит в том, что мы можем вызвать cachingDecorator с любой функцией, 
    // в результате чего мы получим кеширующую обёртку. Это здорово, т.к. 
    // у нас может быть множество функций, использующих такую функциональность, и всё, 
    // что нам нужно сделать – это применить к ним cachingDecorator.

    // Функцию cachingDecorator можно использовать повторно. Мы можем применить её к другой функции.
    // Логика кеширования является отдельной, она не увеличивает сложность самой slow (если таковая была).
    // При необходимости мы можем объединить несколько декораторов (речь об этом пойдёт позже).

}
/*---------------------------------------*/
/*          Применение «func.call» для передачи контекста.          */
{

    // Например, в приведённом ниже коде мы вызываем sayHi в контексте различных объектов: 
    // sayHi.call(user) запускает sayHi, передавая this=user, 
    // а следующая строка устанавливает this=admin:

    function sayHi() {
    alert(this.name);
    }

    let user = { name: "John" };
    let admin = { name: "Admin" };

    // используем 'call' для передачи различных объектов в качестве 'this'
    sayHi.call( user ); // John
    sayHi.call( admin ); // Admin

    // Здесь мы используем call для вызова say с заданным контекстом и фразой:

    function say(phrase) {
    alert(this.name + ': ' + phrase);
    }

    user = { name: "John" };

    // 'user' становится 'this', и "Hello" становится первым аргументом
    say.call( user, "Hello" ); // John: Hello
    // В нашем случае мы можем использовать call в обёртке для передачи контекста в исходную функцию:

    let worker = {
    someMethod() {
        return 1;
    },

    slow(x) {
        alert("Called with " + x);
        return x * this.someMethod(); // (*)
    }
    };

    function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {
        if (cache.has(x)) {
        return cache.get(x);
        }
        let result = func.call(this, x); // теперь 'this' передаётся правильно
        cache.set(x, result);
        return result;
    };
    }

    worker.slow = cachingDecorator(worker.slow); // теперь сделаем её кеширующей

    alert( worker.slow(2) ); // работает
    alert( worker.slow(2) ); // работает, не вызывая первоначальную функцию (кешируется)
    // Теперь всё в порядке.

    // Чтобы всё было понятно, давайте посмотрим глубже, как передаётся this:

    // После декорации worker.slow становится обёрткой function (x) { ... }.
    // Так что при выполнении worker.slow(2) обёртка получает 2 в качестве аргумента и 
    // this=worker (так как это объект перед точкой).
    // Внутри обёртки, если результат ещё не кеширован, func.call(this, x) 
    // передаёт текущий this (=worker) и текущий аргумент (=2) в оригинальную функцию.

}
/*---------------------------------------*/
/*          Переходим к нескольким аргументам с «func.apply»          */
{

    // Есть много возможных решений:

    // Реализовать новую (или использовать стороннюю) структуру данных для коллекции, 
    // которая более универсальна, чем встроенный Map, и поддерживает множественные ключи.

    // Использовать вложенные коллекции: cache.set(min) будет Map, которая хранит пару (max, result). 
    // Тогда получить result мы сможем, вызвав cache.get(min).get(max).

    // Соединить два значения в одно. В нашем конкретном случае мы можем просто использовать 
    // строку "min,max" как ключ к Map. Для гибкости, мы можем позволить передавать хеширующую функцию 
    // в декоратор, которая знает, как сделать одно значение из многих.

    // Для многих практических применений третий вариант достаточно хорош, 
    // поэтому мы будем придерживаться его.

    // Также нам понадобится заменить func.call(this, x) на func.call(this, ...arguments), 
    // чтобы передавать все аргументы обёрнутой функции, а не только первый.

    // Вот более мощный cachingDecorator:

    let worker = {
    slow(min, max) {
        alert(`Called with ${min},${max}`);
        return min + max;
    }
    };

    function cachingDecorator(func, hash) {
    let cache = new Map();
    return function() {
        let key = hash(arguments); // (*)
        if (cache.has(key)) {
        return cache.get(key);
        }

        let result = func.call(this, ...arguments); // (**)

        cache.set(key, result);
        return result;
    };
    }

    function hash(args) {
    return args[0] + ',' + args[1];
    }

    worker.slow = cachingDecorator(worker.slow, hash);

    alert( worker.slow(3, 5) ); // работает
    alert( "Again " + worker.slow(3, 5) ); // аналогично (из кеша)
    
    // Теперь он работает с любым количеством аргументов.

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/