"use strict"
/*          Свойство «name»          */
{

    // Например, имя функции нам доступно как свойство «name»:

    function sayHi() {
    alert("Hi");
    }

    alert(sayHi.name); // sayHi
    // Что довольно забавно, логика назначения name весьма умная. 
    // Она присваивает корректное имя даже в случае, 
    // когда функция создаётся без имени и тут же присваивается, вот так:

    let sayHi = function() {
    alert("Hi");
    };

    alert(sayHi.name); // sayHi (есть имя!)
    // Это работает даже в случае присваивания значения по умолчанию:

    function f(sayHi = function() {}) {
    alert(sayHi.name); // sayHi (работает!)
    }

    f();

    // Также имена имеют и методы объекта:

    let user = {

    sayHi() {
        // ...
    },

    sayBye: function() {
        // ...
    }

    }

    alert(user.sayHi.name); // sayHi
    alert(user.sayBye.name); // sayBye

    // В этом нет никакой магии. Бывает, что корректное имя определить невозможно. 
    // В таких случаях свойство name имеет пустое значение. Например:

    // функция объявлена внутри массива
    let arr = [function() {}];

    alert( arr[0].name ); // <пустая строка>
    // здесь отсутствует возможность определить имя, поэтому его нет

}
/*---------------------------------------*/
/*          Свойство «length»          */
{

    // Ещё одно встроенное свойство «length» содержит количество параметров 
    // функции в её объявлении. Например:

    function f1(a) {}
    function f2(a, b) {}
    function many(a, b, ...more) {}

    alert(f1.length); // 1
    alert(f2.length); // 2
    alert(many.length); // 2

    // Идея состоит в том, чтобы иметь простой синтаксис обработчика без 
    // аргументов для положительных ответов (наиболее распространённый случай), 
    // но также и возможность передавать универсальные обработчики:

    function ask(question, ...handlers) {
        let isYes = confirm(question);

        for(let handler of handlers) {
            if (handler.length == 0) {
                if (isYes) handler();
                } else {
                    handler(isYes);
            }
        }

    }

    // для положительных ответов вызываются оба типа обработчиков
    // для отрицательных - только второго типа

    ask("Вопрос?", () => alert('Вы ответили да'), result => alert(result));

    // Это частный случай так называемого Ad-hoc-полиморфизма – обработка 
    // аргументов в зависимости от их типа или, как в нашем случае – от 
    // значения length. Эта идея имеет применение в библиотеках JavaScript.

}
/*---------------------------------------*/
/*          Пользовательские свойства          */
{

    // Давайте добавим свойство counter для отслеживания общего количества вызовов:

    function sayHi() {
    alert("Hi");

    // давайте посчитаем, сколько вызовов мы сделали
    sayHi.counter++;
    }
    sayHi.counter = 0; // начальное значение

    sayHi(); // Hi
    sayHi(); // Hi

    alert( `Вызвана ${sayHi.counter} раза` ); // Вызвана 2 раза

    // Иногда свойства функции могут использоваться вместо замыканий. 
    // Например, мы можем переписать функцию-счётчик из главы Замыкание, 
    // используя её свойство:

    function makeCounter() {
    // вместо
    // let count = 0

    function counter() {
        return counter.count++;
    };

    counter.count = 0;

    return counter;
    }

    let counter = makeCounter();
    alert( counter() ); // 0
    alert( counter() ); // 1

    // Основное отличие в том, что если значение count живёт во внешней переменной, 
    // то оно не доступно для внешнего кода. Изменить его могут только вложенные 
    // функции. А если оно присвоено как свойство функции, то мы можем его получить:

    counter.count = 10;
    alert( counter() ); // 10

}
/*---------------------------------------*/
/*          Named Function Expression          */
{

    // Например, давайте объявим Function Expression:

    let sayHi = function(who) {
    alert(`Hello, ${who}`);
    };
    // И присвоим ему имя:

    sayHi = function func(who) {
    alert(`Hello, ${who}`);
    };
    // Функция все ещё доступна как sayHi():

    sayHi = function func(who) {
    alert(`Hello, ${who}`);
    };

    sayHi("John"); // Hello, John
    // Есть две важные особенности имени func, ради которого оно даётся:

    // Оно позволяет функции ссылаться на себя же.
    // Оно не доступно за пределами функции.
    // Например, ниже функция sayHi вызывает себя с "Guest", 
    // если не передан параметр who:

    sayHi = function func(who) {
    if (who) {
        alert(`Hello, ${who}`);
    } else {
        func("Guest"); // использует func, чтобы снова вызвать себя же
    }
    };

    sayHi(); // Hello, Guest

    // А вот так - не cработает:
    func(); // Ошибка, func не определена (недоступна вне функции)

    // Вообще, обычно мы можем так поступить:

    sayHi = function(who) {
    if (who) {
        alert(`Hello, ${who}`);
    } else {
        sayHi("Guest");
    }
    };

    // Однако, у этого кода есть проблема, которая заключается в том, 
    // что значение sayHi может быть изменено. 
    // Функция может быть присвоена другой переменной, 
    // и тогда код начнёт выдавать ошибки:

    sayHi = function(who) {
    if (who) {
        alert(`Hello, ${who}`);
    } else {
        sayHi("Guest"); // Ошибка: sayHi не является функцией
    }
    };

    let welcome = sayHi;
    sayHi = null;

    welcome(); // Ошибка, вложенный вызов sayHi больше не работает!

    // Давайте используем его, чтобы исправить наш код:

    sayHi = function func(who) {
    if (who) {
        alert(`Hello, ${who}`);
    } else {
        func("Guest"); // Теперь всё в порядке
    }
    };

    welcome = sayHi;
    sayHi = null;

    welcome(); // Hello, Guest (вложенный вызов работает)

}
/*---------------------------------------*/
/*          итого          */
{

    // Функции – это объекты.

    // Их свойства:

    // name – имя функции. Обычно берётся из объявления функции, 
    // но если там нет – JavaScript пытается понять его из контекста.
    // length – количество аргументов в объявлении функции. 
    // Троеточие («остаточные параметры») не считается.
    // Если функция объявлена как Function Expression (вне основного потока кода) и 
    // имеет имя, тогда это называется Named Function Expression 
    // (Именованным Функциональным Выражением). 
    // Это имя может быть использовано для ссылки на себя же, 
    // для рекурсивных вызовов и т.п.

    // Также функции могут содержать дополнительные свойства. 
    // Многие известные JavaScript-библиотеки искусно используют эту возможность.

    // Они создают «основную» функцию и добавляют множество «вспомогательных» 
    // функций внутрь первой. Например, библиотека jQuery создаёт функцию с 
    // именем $. Библиотека lodash создаёт функцию _, а потом добавляет в неё
    //  _.clone, _.keyBy и другие свойства (чтобы узнать о ней побольше см. 
    //     документацию). Они делают это, чтобы уменьшить засорение глобального 
    //     пространства имён посредством того, что одна библиотека предоставляет 
    //     только одну глобальную переменную, уменьшая вероятность конфликта имён.

    // Таким образом, функция может не только делать что-то сама по себе, 
    // но также и предоставлять полезную функциональность через свои свойства.

}
/*---------------------------------------*/
/*          Задачи          */
{

    // Установка и уменьшение значения счётчика

    function makeCounter() {
    
        counter.count = 0;
       
       function counter() {
       return counter.count++;
       };
   
       counter.set = function set(n) {
       return counter.count = n;
       };
   
       counter.decrease = function decrease() {
       return counter.count--;
       };
   
     return counter;
     
     }

     function makeCounter() {
        let count = 0;
      
        function counter() {
          return count++;
        }
      
        counter.set = value => count = value;
      
        counter.decrease = () => count--;
      
        return counter;
      }
     
     let counter = makeCounter();
     
     alert( counter() ); // 0
     alert( counter() ); // 1
     
     counter.set(10); // установить новое значение счётчика
     
     alert( counter() ); // 10
     
     counter.decrease(); // уменьшить значение счётчика на 1
     
     alert( counter() ); // 10 (вместо 11)

    //  Сумма с произвольным количеством скобок

    function sum(a){
        
        let count = a;

        function nextCount(n){
            count += n;
            return nextCount;
        }

        nextCount.toString = () => {return count};

        return nextCount

    }

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
