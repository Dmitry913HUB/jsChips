/*          Два способа мышления          */
{

    // Рассмотрим два способа её реализации.

    // Итеративный способ: цикл for:

    function pow(x, n) {
    let result = 1;

    // умножаем result на x n раз в цикле
    for (let i = 0; i < n; i++) {
        result *= x;
    }

    return result;
    }

    alert( pow(2, 3) ); // 8
    // Рекурсивный способ: упрощение задачи и вызов функцией самой себя:

    function pow(x, n) {
    if (n == 1) {
        return x;
    } else {
        return x * pow(x, n - 1);
    }
    }

    alert( pow(2, 3) ); // 8

    // огда функция pow(x, n) вызывается, исполнение делится на две ветви:

    //             if n==1  = x
    //             /
    // pow(x, n) =
    //             \
    //             else     = x * pow(x, n - 1)

    function pow(x, n) {
        return (n == 1) ? x : (x * pow(x, n - 1));
    }

}
/*---------------------------------------*/
/*          Контекст выполнения, стек          */
{

    // Когда функция производит вложенный вызов, происходит следующее:

    // Выполнение текущей функции приостанавливается.
    // Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – 
    // стеке контекстов выполнения.
    // Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
    // После их завершения старый контекст достаётся из стека, и выполнение внешней 
    // функции возобновляется с того места, где она была остановлена.

}
/*---------------------------------------*/
/*          Рекурсивные обходы          */
{

    // Как мы видим, когда наша функция получает отдел для подсчёта суммы зарплат, есть два возможных случая:

    // Либо это «простой» отдел с массивом – тогда мы сможем суммировать зарплаты в простом цикле.
    // Или это объект с N подотделами – тогда мы можем сделать N рекурсивных вызовов, 
    // чтобы получить сумму для каждого из подотделов, и объединить результаты.
    // Случай (1), когда мы получили массив, является базой рекурсии, тривиальным случаем.

    // Случай (2), при получении объекта, является шагом рекурсии. 
    // Сложная задача разделяется на подзадачи для подотделов. 
    // Они могут, в свою очередь, снова разделиться на подотделы, но рано или поздно это разделение закончится, 
    // и решение сведётся к случаю (1).

    // Алгоритм даже проще читается в виде кода:

    let company = { // тот же самый объект, сжатый для краткости
    sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
    development: {
        sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
        internals: [{name: 'Jack', salary: 1300}]
    }
    };

    // Функция для подсчёта суммы зарплат
    function sumSalaries(department) {
    if (Array.isArray(department)) { // случай (1)
        return department.reduce((prev, current) => prev + current.salary, 0); // сумма элементов массива
    } else { // случай (2)
        let sum = 0;
        for (let subdep of Object.values(department)) {
        sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты
        }
        return sum;
    }
    }

    alert(sumSalaries(company)); // 6700

}
/*---------------------------------------*/
/*          Рекурсивные структуры          */
{

    // Элемент связанного списка определяется рекурсивно как объект с:

    // value,
    // next – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.

    let list = {
    value: 1,
    next: {
        value: 2,
        next: {
        value: 3,
        next: {
            value: 4,
            next: null
        }
        }
    }
    };

    // Альтернативный код для создания:

    list = { value: 1 };
    list.next = { value: 2 };
    list.next.next = { value: 3 };
    list.next.next.next = { value: 4 };

    // Список можно легко разделить на несколько частей и впоследствии объединить обратно:

    let secondList = list.next.next;
    list.next.next = null;

    // Для объединения:

    list.next.next = secondList;
    // И, конечно, мы можем вставить или удалить элементы из любого места.

    // Например, для добавления нового элемента нам нужно обновить первый элемент списка:

    list = { value: 1 };
    list.next = { value: 2 };
    list.next.next = { value: 3 };
    list.next.next.next = { value: 4 };

    // добавление нового элемента в список
    list = { value: "new item", next: list };

    // Чтобы удалить элемент из середины списка, нужно изменить значение next предыдущего элемента:

    list.next = list.next.next;


}
/*---------------------------------------*/
/*          итого          */
{

    // Термины:

    // Рекурсия – это термин в программировании, означающий вызов функцией самой себя. 
    // Рекурсивные функции могут быть использованы для элегантного решения определённых задач.

    // Когда функция вызывает саму себя, это называется шагом рекурсии. 
    // База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, 
    // что решение не требует дальнейших вложенных вызовов.

    // Рекурсивно определяемая структура данных – это структура данных, 
    // которая может быть определена с использованием самой себя.

    // Например, связанный список может быть определён как структура данных, 
    // состоящая из объекта, содержащего ссылку на список (или null).

    // list = { value, next -> list }
    // Деревья, такие как дерево HTML-элементов или дерево отделов из этой главы, 
    // также являются рекурсивными: у них есть ветви, и каждая ветвь может содержать другие ветви.

    // Как мы видели в примере sumSalary, рекурсивные функции могут быть использованы для прохода по ним.

}
/*---------------------------------------*/
/*          Задачи          */
{

    //zadacha 1 Вычислить сумму чисел до данного

    function sumTo(n) {
        if (n === 1){
            return n
        }
        return n + sumTo(n - 1);
    }

    alert( sumTo(100) ); // 5050

    // Решение по формуле: sumTo(n) = n*(n+1)/2:

    function sumTo(n) {
    return n * (n + 1) / 2;
    }

    alert( sumTo(100) );

    //zad 2 Вычислить факториал

    function factorial(n){
        if (n === 1) return 1;
        return n * factorial(n - 1);

        // return (n != 1) ? n * factorial(n - 1) : 1;
    }

    alert( factorial(5) ); // 120

    // zadacha 3 fibonachi

    function fib(n) {
        if (n === 0) { return 0}
        if (n === 1) { return 1}
        return fib(n - 1) + fib(n - 2)

        // return n <= 1 ? n : fib(n - 1) + fib(n - 2);
    }

    function fib(n) {
        let a = 1;
        let b = 1;
        for (let i = 3; i <= n; i++) {
          let c = a + b;
          a = b;
          b = c;
        }
        return b;
      }
      
      alert( fib(3) ); // 2
      alert( fib(7) ); // 13
      alert( fib(77) ); // 5527939700884757

    alert(fib(3)); // 2
    alert(fib(7)); // 13
    alert(fib(77)); // 5527939700884757

    // zadacha 4 Вывод односвязного списка

    function printList(list){
        alert(list.value)

        if (list.next) printList(list.next);
    }

    function printList(list) {
        let tmp = list;
      
        while (tmp) {
          alert(tmp.value);
          tmp = tmp.next;
        }
      
    }

    let list = {
        value: 1,
        next: {
          value: 2,
          next: {
            value: 3,
            next: {
              value: 4,
              next: null
            }
          }
        }
      };

    printList(list)

    // zad 5 Вывод односвязного списка в обратном порядке

    function printRevList(list){
        
        if (list.next) printList(list.next);

        alert(list.value)
    }

    function printRevList(list) {
        let arr = [];
        let tmp = list;

        while (tmp) {
            arr.push(tmp.value);
            tmp = tmp.next;
        }

        for (let i = arr.length - 1; i >= 0; i--) {
            alert( arr[i] );
        }
      
    }

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/