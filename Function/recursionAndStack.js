/*          Два способа мышления          */
{

    // Рассмотрим два способа её реализации.

    // Итеративный способ: цикл for:

    function pow(x, n) {
    let result = 1;

    // умножаем result на x n раз в цикле
    for (let i = 0; i < n; i++) {
        result *= x;
    }

    return result;
    }

    alert( pow(2, 3) ); // 8
    // Рекурсивный способ: упрощение задачи и вызов функцией самой себя:

    function pow(x, n) {
    if (n == 1) {
        return x;
    } else {
        return x * pow(x, n - 1);
    }
    }

    alert( pow(2, 3) ); // 8

    // огда функция pow(x, n) вызывается, исполнение делится на две ветви:

    //             if n==1  = x
    //             /
    // pow(x, n) =
    //             \
    //             else     = x * pow(x, n - 1)

    function pow(x, n) {
        return (n == 1) ? x : (x * pow(x, n - 1));
    }

}
/*---------------------------------------*/
/*          Контекст выполнения, стек          */
{

    // Когда функция производит вложенный вызов, происходит следующее:

    // Выполнение текущей функции приостанавливается.
    // Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – 
    // стеке контекстов выполнения.
    // Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
    // После их завершения старый контекст достаётся из стека, и выполнение внешней 
    // функции возобновляется с того места, где она была остановлена.

}
/*---------------------------------------*/
/*          Рекурсивные обходы          */
{

    // Как мы видим, когда наша функция получает отдел для подсчёта суммы зарплат, есть два возможных случая:

    // Либо это «простой» отдел с массивом – тогда мы сможем суммировать зарплаты в простом цикле.
    // Или это объект с N подотделами – тогда мы можем сделать N рекурсивных вызовов, 
    // чтобы получить сумму для каждого из подотделов, и объединить результаты.
    // Случай (1), когда мы получили массив, является базой рекурсии, тривиальным случаем.

    // Случай (2), при получении объекта, является шагом рекурсии. 
    // Сложная задача разделяется на подзадачи для подотделов. 
    // Они могут, в свою очередь, снова разделиться на подотделы, но рано или поздно это разделение закончится, 
    // и решение сведётся к случаю (1).

    // Алгоритм даже проще читается в виде кода:

    let company = { // тот же самый объект, сжатый для краткости
    sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
    development: {
        sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
        internals: [{name: 'Jack', salary: 1300}]
    }
    };

    // Функция для подсчёта суммы зарплат
    function sumSalaries(department) {
    if (Array.isArray(department)) { // случай (1)
        return department.reduce((prev, current) => prev + current.salary, 0); // сумма элементов массива
    } else { // случай (2)
        let sum = 0;
        for (let subdep of Object.values(department)) {
        sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты
        }
        return sum;
    }
    }

    alert(sumSalaries(company)); // 6700

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/
/*          итого          */
{

}
/*---------------------------------------*/