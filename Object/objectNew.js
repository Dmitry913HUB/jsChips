/*          Функция-конструктор        */
{
    function User(name) {
        this.name = name;
        this.isAdmin = false;
      }
      
      let user = new User("Jack");
      
      alert(user.name); // Jack
      alert(user.isAdmin); // false

    // Когда функция вызывается как new User(...), происходит следующее:

    // Создаётся новый пустой объект, и он присваивается this.
    // Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
    // Возвращается значение this.
    // Другими словами, new User(...) делает что-то вроде:

    function User(name) {
    // this = {};  (неявно)

    // добавляет свойства к this
    this.name = name;
    this.isAdmin = false;

    // return this;  (неявно)
    }

    //Подобные функции должны начинаться с заглавной буквы – это общепринятое соглашение, чтобы было ясно, что функция должна вызываться с помощью «new».
}
/*---------------------------------------*/
/*          Проверка на вызов в режиме конструктора: new.target        */
{
    // Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.
    // В случае обычного вызова функции new.target будет undefined. Если же она была вызвана при помощи new, new.target будет равен самой функции.

    function User() {
    alert(new.target);
    }

    // без "new":
    User(); // undefined

    // с "new":
    new User(); // function User { ... }

    // Это можно использовать внутри функции, чтобы узнать, была ли она вызвана при помощи new, «в режиме конструктора», или без него, «в обычном режиме».
    // Также мы можем сделать, чтобы вызовы с new и без него делали одно и то же:

    function User(name) {
    if (!new.target) { // в случае, если вы вызвали меня без оператора new
        return new User(name); // ...я добавлю new за вас
    }

    this.name = name;
    }

    let john = User("John"); // переадресовывает вызов на new User
    alert(john.name); // John

}
/*---------------------------------------*/
/*          Возврат значения из конструктора, return        */
{
    // Но если return всё же есть, то применяется простое правило:

    // При вызове return с объектом, вместо this вернётся объект.
    // При вызове return с примитивным значением, оно проигнорируется.
    // Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.

    // К примеру, здесь return замещает this, возвращая объект:

    function BigUser() {

    this.name = "John";

    return { name: "Godzilla" };  // <-- возвращает этот объект
    }

    alert( new BigUser().name );  // Godzilla, получили этот объект

    //вот пример с пустым return (или мы могли бы поставить примитив после return, неважно):

    function SmallUser() {
    
      this.name = "John";
    
      return; // <-- возвращает this
    }
    
    alert( new SmallUser().name );  // John

}
/*---------------------------------------*/
/*          Создание методов в конструкторе        */
{
    // Конечно, мы можем добавить к this не только свойства, но и методы
    // Например, new User(name) ниже создаёт объект с заданным name и методом sayHi:

    function User(name) {
    this.name = name;

    this.sayHi = function() {
            alert( "Меня зовут: " + this.name );
        };
    }

    let john = new User("John");

    john.sayHi(); // Меня зовут: John

    /*
    john = {
    name: "John",
    sayHi: function() { ... }
    }
    */

}
/*---------------------------------------*/
/*          Итого        */
{
    // Функции-конструкторы или просто конструкторы, являются обычными функциями, но существует общепринятое соглашение именовать их с заглавной буквы.
    // Функции-конструкторы следует вызывать только с помощью new. Такой вызов подразумевает создание пустого this в начале и возврат заполненного в конце.

    // Мы можем использовать конструкторы для создания множества похожих объектов.

    // JavaScript предоставляет функции-конструкторы для множества встроенных объектов языка: таких как Date, Set, и других

}
/*---------------------------------------*/
/*          Задачи        */
{

    //Возможно ли создать функции A и B, чтобы new A() == new B()?

    //Таким образом, они могут, к примеру, возвращать один и тот же внешне определённый объект obj:

    let obj = {};

    function A() { return obj; }
    function B() { return obj; }

    alert( new A() == new B() ); // true

    //Создайте калькулятор при помощи конструктора, new Calculator

    function Calculator() {

        this.read = function() {
          this.a = +prompt('a?', 0);
          this.b = +prompt('b?', 0);
        };
      
        this.sum = function() {
          return this.a + this.b;
        };
      
        this.mul = function() {
          return this.a * this.b;
        };
    }
      
      let calculator = new Calculator();
      calculator.read();
      
      alert( "Sum=" + calculator.sum() );
      alert( "Mul=" + calculator.mul() );

    //Создайте new Accumulator

    function Accumulator(startingValue){
        this.value = this.startingValue;
        this.read = function(){
            this.value += +prompt("enter number", 0)
        }
    }

    let accumulator = new Accumulator(1); // начальное значение 1

    accumulator.read(); // прибавляет введённое пользователем значение к текущему значению
    accumulator.read(); // прибавляет введённое пользователем значение к текущему значению

    alert(accumulator.value); // выведет сумму этих значений

}
/*---------------------------------------*/
/*          Итого        */
{

}
/*---------------------------------------*/