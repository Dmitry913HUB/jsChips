"use strict";
/*          Хинты       */
{
    //"string"
    //Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:

    // вывод
    alert(obj);

    // используем объект в качестве ключа
    anotherObj[obj] = 123;

    //"number"
    //Для преобразования объекта к числу, в случае математических операций:

    // явное преобразование
    let num = Number(obj);

    // математические (не считая бинарного плюса)
    let n = +obj; // унарный плюс
    let delta = date1 - date2;

    // сравнения больше/меньше
    let greater = user1 > user2;

    //"default"
    //Происходит редко, когда оператор «не уверен», какой тип ожидать.
    //Например, бинарный плюс + может работать как со строками (объединяя их в одну), так и с числами (складывая их). Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.
    //Также, если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно, какое преобразование следует выполнить, поэтому используется хинт "default".

    // бинарный плюс использует хинт "default"
    let total = obj1 + obj2;

    // obj == number использует хинт "default"
    if (user == 1) {};

    //Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:

    //Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,

    //Иначе, если хинт равен "string"
    //попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.

    //Иначе, если хинт равен "number" или "default"
    //попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.

}
/*---------------------------------------*/
/*          Symbol.toPrimitive        */
{
    //Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.
    //Например, здесь объект user реализует его:

    let user = {
        name: "John",
        money: 1000,

        [Symbol.toPrimitive](hint) {
                alert(`hint: ${hint}`);
                return hint == "string" ? `{name: "${this.name}"}` : this.money;
        }
    };

    // демонстрация результатов преобразований:
    alert(user); // hint: string -> {name: "John"}
    alert(+user); // hint: number -> 1000
    alert(user + 500); // hint: default -> 1500

}
/*---------------------------------------*/
/*          toString/valueOf        */
{
    // По умолчанию обычный объект имеет следующие методы toString и valueOf:

    // Метод toString возвращает строку "[object Object]".
    // Метод valueOf возвращает сам объект.
    // Взгляните на пример:

    let user = {name: "John"};

    alert(user); // [object Object]
    alert(user.valueOf() === user); // true

    //Для примера, используем их в реализации всё того же объекта user. Но уже используя комбинацию toString и valueOf вместо Symbol.toPrimitive:

    user = {
        name: "John",
        money: 1000,

        // для хинта равного "string"
        toString() {
            return `{name: "${this.name}"}`;
        },

        // для хинта равного "number" или "default"
        valueOf() {
            return this.money;
        }

    };

    alert(user); // toString -> {name: "John"}
    alert(+user); // valueOf -> 1000
    alert(user + 500); // valueOf -> 1500

    //Довольно часто нам нужно единое «универсальное» место для обработки всех примитивных преобразований. В этом случае мы можем реализовать только toString:

    user = {
        name: "John",

        toString() {
            return this.name;
        }
    };

    alert(user); // toString -> John
    alert(user + 500); // toString -> John500

}
/*---------------------------------------*/
/*          Дальнейшие преобразования        */
{

    // Объект преобразуется в примитив (с использованием правил, описанных выше).
    // Если необходимо для дальнейших вычислений, этот примитив преобразуется дальше.
    // Например:

    let obj = {
        // toString обрабатывает все преобразования в случае отсутствия других методов
        toString() {
            return "2";
        }
    };

    alert(obj * 2); // 4, объект был преобразован к примитиву "2", затем умножение сделало его числом

    //А вот, к примеру, бинарный плюс в подобной ситуации соединил бы строки, так как он совсем не брезгует строк:

    obj = {
        toString() {
            return "2";
        }
    };

    alert(obj + 2); // 22 ("2" + 2), преобразование к примитиву вернуло строку => конкатенация

}
/*---------------------------------------*/
/*          Итого        */
{

    // Преобразование объекта в примитив вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве значения.

    // Существует всего 3 типа (хинта) для этого:

    // "string" (для alert и других операций, которым нужна строка)
    // "number" (для математических операций)
    // "default" (для некоторых других операторов, обычно объекты реализуют его как "number")
    // Спецификация явно описывает для каждого оператора, какой ему следует использовать хинт.

    // Алгоритм преобразования таков:

    // Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует,
    // В случае, если хинт равен "string"
    // происходит попытка вызвать obj.toString() и obj.valueOf(), смотря что есть.
    // В случае, если хинт равен "number" или "default"
    // происходит попытка вызвать obj.valueOf() и obj.toString(), смотря что есть.
    // Все эти методы должны возвращать примитив (если определены).

    // На практике часто бывает достаточно реализовать только obj.toString() в качестве универсального метода для преобразований к строке, 
    // который должен возвращать удобочитаемое представление объекта для целей логирования или отладки.

}
/*---------------------------------------*/