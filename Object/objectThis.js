"use strict"
/*          Примеры методов          */
{
    //Для начала давайте научим нашего пользователя user здороваться:

    let user = {
        name: "John",
        age: 30
    };

    // сначала, объявляем
    // function sayHi() {
    //     alert("Привет!");
    // }
    
    // // затем добавляем в качестве метода
    // user.sayHi = sayHi;

    user.sayHi = function() {
        alert("Привет!");
    };

    user.sayHi(); // Привет!

    //Существует более короткий синтаксис для методов в литерале объекта:

    // эти объекты делают одно и то же

    user = {
        sayHi: function() {
        alert("Привет");
        }
    };

    // сокращённая запись выглядит лучше, не так ли?
    user = {
        sayHi() { // то же самое, что и "sayHi: function(){...}"
        alert("Привет");
        }
    };
}
/*---------------------------------------*/
/*          Ключевое слово «this» в методах         */
{
    //Для доступа к информации внутри объекта метод может использовать ключевое слово this.
    //Значение this – это объект «перед точкой», который используется для вызова метода.
    
    let user = {
      name: "John",
      age: 30,
    
      sayHi() {
        // "this" - это "текущий объект".
        alert(this.name);
      }
    
    };
    
    user.sayHi(); // John

    //Технически также возможно получить доступ к объекту без ключевого слова this, обратившись к нему через внешнюю переменную (в которой хранится ссылка на этот объект):

    user = {
        name: "John",
        age: 30,

        sayHi() {
            alert(user.name); // "user" вместо "this"
        }
    };

    // но такой код будет с ошибкой так что такой вариант использования не рекомендуется если требуется обратиться к методу или переменной обекта

    user = {
        name: "John",
        age: 30,
      
        sayHi() {
          alert( user.name ); // приведёт к ошибке
        }
      
      };
      
      
      let admin = user;
      user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.
      
      admin.sayHi(); // TypeError: Cannot read property 'name' of null

}
/*---------------------------------------*/
/*          «this» не является фиксированным         */
{
    //В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. Его можно использовать в любой функции, даже если это не метод объекта.

    //В JavaScript ключевое слово «this» обращается к вышележащему контексту его вызова.

    function sayHi() {
    alert( this.name );
    }

    let user = { name: "John" };
    let admin = { name: "Admin" };

    function sayHi() {
        alert( this.name );
    }

    // используем одну и ту же функцию в двух объектах
    user.f = sayHi;
    admin.f = sayHi;

    // эти вызовы имеют  разное значение this
    // "this" внутри функции - это объект "перед точкой"
    user.f(); // John  (this == user)
    admin.f(); // Admin  (this == admin)

    admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)

    //Правило простое: если вызывается obj.f(), то во время вызова f, this – это obj. Так что, в приведённом выше примере это либо user, либо admin.


    //Вызов без объекта: this == undefined
    //Мы даже можем вызвать функцию вообще без объекта:

    function sayHi() {
        alert(this);
    }

    sayHi(); // undefined

    //В строгом режиме ("use strict") в таком коде значением this будет являться undefined. Если мы попытаемся получить доступ к this.name – это вызовет ошибку.
}
/*---------------------------------------*/
/*          У стрелочных функций нет «this»         */
{
    //Стрелочные функции особенные: у них нет своего «собственного» this. Если мы ссылаемся на this внутри такой функции, то оно берётся из внешней «нормальной» функции.

    //Например, здесь arrow() использует значение this из внешнего метода user.sayHi():

    let user = {
    firstName: "Ilya",
    sayHi() {
        let arrow = () => alert(this.firstName);
        arrow();
    }
    };

    user.sayHi(); // Ilya

}
/*---------------------------------------*/
/*          Итого        */
{
    // Функции, которые находятся в свойствах объекта, называются «методами».
    // Методы позволяют объектам «действовать»: object.doSomething().
    // Методы могут ссылаться на объект через this.

    // Значение this определяется во время исполнения кода.

    // При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
    // Функция может быть скопирована между объектами (из одного объекта в другой).
    // Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.

    // Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this. Когда внутри стрелочной функции обращаются к this, то его значение берётся извне.
}
/*---------------------------------------*/
/*          Задачи        */
{
    //Здесь функция makeUser возвращает объект.

    //Каким будет результат при обращении к свойству объекта ref? Почему?

    function makeUser() {
    return {
        name: "John",
        ref: this
    };
    }

    let user = makeUser();

    alert( user.ref.name ); // Каким будет результат?

    //Ответ: ошибка.

    function makeUser() {
    return {
        name: "John",
        ref: this
    };
    }

    user = makeUser();

    alert( user.ref.name ); // Error: Cannot read property 'name' of undefined

    // Это потому, что правила, которые определяют значение this, никак не смотрят на объявление объекта. Важен лишь момент вызова.
    // Здесь значение this внутри makeUser() равно undefined, потому что оно вызывается как функция, а не через «точечный» синтаксис как метод.
    // Значение this одно для всей функции, блоки кода и объектные литералы на него не влияют.
    // Таким образом, ref: this фактически принимает текущее this функции makeUser().
    // Мы можем переписать функцию и вернуть то же самое this со значением undefined:

    function makeUser(){
    return this; // на этот раз нет литерала объекта
    }

    alert( makeUser().name ); // Error: Cannot read property 'name' of undefined

    // Как вы можете видеть, результат alert( makeUser().name ) совпадает с результатом alert( user.ref.name ) из предыдущего примера.
    // Вот противоположный случай:

    function makeUser() {
    return {
        name: "John",
        ref() {
        return this;
        }
    };
    }

    user = makeUser();

    alert( user.ref().name ); // John

    //Теперь это работает, поскольку user.ref() – это метод. И значением this становится объект перед точкой .


    //Создайте объект calculator (калькулятор) с тремя методами:

    // read() (читать) запрашивает два значения и сохраняет их как свойства объекта.
    // sum() (суммировать) возвращает сумму сохранённых значений.
    // mul() (умножить) перемножает сохранённые значения и возвращает результат.

    let calculator = {
        values1: 0,
        values2: 0,
        read(){
            this.values1 = +prompt("enter values1", 0);
            this.values2 = +prompt("enter values2", 0)
        },
        sum(){
            return this.values1 + this.values2
        },
        mul(){
            return this.values1 * this.values2
        }
    };

    calculator.read();
    alert( calculator.sum() );
    alert( calculator.mul() );

    //У нас есть объект ladder (лестница), который позволяет подниматься и спускаться:

    let ladder = {
        step: 0,
        up() {
            this.step++;
            return this;
        },
        down() {
            this.step--;
            return this;
        },
        showStep: function() { // показывает текущую ступеньку
            alert( this.step );
            return this;
        }
    };

    //Теперь, если нам нужно выполнить несколько последовательных вызовов, мы можем сделать это так:

    ladder.up();
    ladder.up();
    ladder.down();
    ladder.showStep(); // 1
    ladder.down();
    ladder.showStep(); // 0
    //Измените код методов up, down и showStep таким образом, чтобы их вызов можно было сделать по цепочке, например так:

    ladder.up().up().down().showStep().down().showStep(); // показывает 1 затем 0

}
/*---------------------------------------*/
/*          Итого        */
{

}
/*---------------------------------------*/